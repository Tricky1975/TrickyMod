Strict
Import tricky_units.StringMap
Import tricky_units.advdatetime
Import tricky_units.Listfile

MKL_Version "",""
MKL_Lic     "",""

Rem 
bbdoc: Variable used by init reader/writer
End Rem
Type TIni
	Field Vars:StringMap = New StringMap
	Field Lists:TMap = New TMap
	
	Rem
	bbdoc: read var from ini
	End Rem
	
	Method C$(T$)
	Return Vars.value(Upper(T))
	End Method
	
	Rem
	bbdoc: write var to ini
	End Rem
	Method D(T$,V$)
	MapInsert Vars,Upper(T),V
	End Method
	
	Rem
	bbdoc: creates a list, in the ini
	End Rem
	Method CList(T$)
	MapInsert lists,Upper(T),New TList
	End Method
	
	Rem
	bbdoc: Returns a list if it exists as a TLIST. (Please note, this TLIST may ONLY contain strings).
	End Rem
	Method List:TList(T$)
	Local ret:TList = TList(MapValueForKey(lists,Upper(T)))
	If Not ret Print("WARNING! List "+T+" not found!")
	Return ret
	End Method
	
	Rem
	bbdoc: Creates a duplicate reference of the of the list in a new TAG. If the target list exists, it will be destroyed.
	End Rem
	Method DuplicateList(Original$,Target$)
	Local T:TList = list(original)
	Assert T Else "Original list does not exist"
	If Not t Return Print("WARNING! List "+original+" does not exist!")
	MapInsert lists,Upper(TARGET),T
	End Method
	
	End Type
	
	
Const AllowedChars$ = "qwertyuiopasdfghjklzxcvbnm[]{}1234567890-_+!@%^&*()_+QWERTYUIOPASDFGHJKL|ZXCVBNM<>?/ '."

Function IniString$(A$,XAllow$="")
Local i
Local ret$[] = ["",A]
Local allowed = True
For i=0 Until Len(A)
	allowed = allowed And (allowedchars+XAllow).find(Chr(A[i]))>=0
	'If Not allowed Print "I will not allow: "+Chr(A[i])+"/"+A
	ret[0]:+"#("+A[i]+")"
	Next
Return ret[allowed]	
End Function

Function UnIniString$(A$)
Local ret$=A
Local i
For i=0 Until 256
	ret = Replace(ret,"#("+i+")",Chr(i))
	Next
Return ret	
End Function

Rem
bbdoc: Saves ini data into a file.
about: The "File" variable, may be a string containing the file name, or a stream to which you want to add this data.
End Rem
Function SaveIni(file:Object,Ini:TIni)	
Local BT:TStream
Local f
Local Done:TList = New TList
Local L:TList = New TList
Local LN$,Dupe
Local K$
If String(file)
	f = True
	bt = WriteFile(String(file))
ElseIf TStream(file)
	f = False
	bt = TStream(file) 	
	EndIf
WriteLine bt,"[rem]~nGenerated by: "+AppFile+" ("+AppTitle+")~n"+PNow()+"~n"
WriteLine bt,"[vars]"
For K$=EachIn(MapKeys(ini.Vars))
	WriteLine bt,IniString(K)+"="+IniString(Ini.C(K),",.")
	Next
WriteLine bt,""
For K$=EachIn(MapKeys(ini.lists))
	LN$=IniString(K)
	If Not ListContains(L,K)
		For Local K2$=EachIn(MapKeys(ini.lists))
			If K<>K2 And (Not ListContains(L,K2)) And ini.list(K)=ini.list(K2) Then
				LN:+","+IniString(K2)
				ListAddLast L,K2
				EndIf
			Next
		WriteLine BT,"[List:"+LN+"]"	
		For Local V$=EachIn ini.list(K)
			WriteLine bt,IniString(V)
			Next
		EndIf	
	Next	
If f CloseFile bt
End Function			
			
Rem
bbdoc: Loads an ini into a file. 
about: When merge is set to 1, the data from the ini var is linked to the existing ini var if it's not null. The "File" variable can be any type ReadStream() accepts for filereading.
End Rem
Function LoadIni(File:Object,Ini:TIni Var,Merge=False)
If Merge Or (Not Ini) Ini=New TIni
Local wtag$,Lst:TList,line$,tag$,tagsplit$[],tagparam$[]
tag$="REM"
For line=EachIn Listfile(File)
	If line Then
		If Left(Trim(line),1)="[" And Right(Trim(line),1)="]" 
			wTag = Mid(Trim(line),2,Len(Trim(line))-2)
			tagsplit=wTag.split(":")
			tag = tagsplit[0].toupper()
			If Upper(Tagsplit[0])="LIST"
				If Len(Tagsplit[0])<2 Return Print("ERROR! Incorrectly defined list!")
				lst = New TList				
				For Local K$=EachIn tagsplit[1].split(",")
					'ini.clist(UnIniString(K))
					MapInsert Ini.Lists,Upper(UnIniString(K)),lst
					Next
				'lst=ini.list(UnIniString(K))	
				EndIf
		Else
			Select tag
				Case "REM"
				Case "VARS"
					If line.find("=")<0 
						Print "Warning! Invalid var definition: "+Line
					Else
						tagsplit=line.split("=")
						Ini.D UnIniString(tagsplit[0]),UnIniString(tagsplit[1])
						EndIf
				Case "LIST"
					ListAddLast lst,uninistring(line)
				End Select	
			EndIf
		EndIf		
	Next
End Function
